-- Create inventory table
CREATE TABLE IF NOT EXISTS inventory (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bar_id UUID NOT NULL REFERENCES bars(id) ON DELETE CASCADE,
    brand_id BIGINT NOT NULL REFERENCES brands(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    opening_qty INTEGER NOT NULL DEFAULT 0,
    receipt_qty INTEGER NOT NULL DEFAULT 0,
    sale_qty INTEGER NOT NULL DEFAULT 0,
    closing_qty INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    CONSTRAINT unique_inventory_entry UNIQUE (bar_id, brand_id, date)
);

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_inventory_bar_id ON inventory(bar_id);
CREATE INDEX IF NOT EXISTS idx_inventory_brand_id ON inventory(brand_id);
CREATE INDEX IF NOT EXISTS idx_inventory_date ON inventory(date);

-- Enable Row Level Security
ALTER TABLE inventory ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if it exists
DROP POLICY IF EXISTS "Allow all access to inventory" ON inventory;

-- Create open policy for all access
CREATE POLICY "Allow all access to inventory"
    ON inventory FOR ALL
    USING (true)
    WITH CHECK (true);

-- Create function to update closing quantity
CREATE OR REPLACE FUNCTION update_inventory_closing_qty()
RETURNS TRIGGER AS $$
BEGIN
    NEW.closing_qty := NEW.opening_qty + NEW.receipt_qty - NEW.sale_qty;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to update closing quantity
DROP TRIGGER IF EXISTS update_closing_qty ON inventory;
CREATE TRIGGER update_closing_qty
    BEFORE INSERT OR UPDATE ON inventory
    FOR EACH ROW
    EXECUTE FUNCTION update_inventory_closing_qty();

-- Create function to update next day's opening quantity
CREATE OR REPLACE FUNCTION update_next_day_opening_qty()
RETURNS TRIGGER AS $$
BEGIN
    -- Update opening quantity for the next day
    UPDATE inventory
    SET opening_qty = NEW.closing_qty
    WHERE bar_id = NEW.bar_id
    AND brand_id = NEW.brand_id
    AND date = NEW.date + INTERVAL '1 day';
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to update next day's opening quantity
DROP TRIGGER IF EXISTS update_next_day_opening ON inventory;
CREATE TRIGGER update_next_day_opening
    AFTER INSERT OR UPDATE ON inventory
    FOR EACH ROW
    EXECUTE FUNCTION update_next_day_opening_qty();

-- Create function to sync TP receipts
CREATE OR REPLACE FUNCTION sync_tp_receipts()
RETURNS TRIGGER AS $$
BEGIN
    -- Update receipt quantity in inventory
    UPDATE inventory
    SET receipt_qty = (
        SELECT COALESCE(SUM(qty), 0)
        FROM tp_items ti
        JOIN transport_permits tp ON ti.tp_id = tp.id
        WHERE tp.bar_id = NEW.bar_id
        AND ti.brand_id = NEW.brand_id
        AND tp.tp_date = NEW.date
    )
    WHERE bar_id = NEW.bar_id
    AND brand_id = NEW.brand_id
    AND date = NEW.date;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to sync TP receipts
DROP TRIGGER IF EXISTS sync_tp_receipts_trigger ON tp_items;
CREATE TRIGGER sync_tp_receipts_trigger
    AFTER INSERT OR UPDATE OR DELETE ON tp_items
    FOR EACH ROW
    EXECUTE FUNCTION sync_tp_receipts();

-- Create function to sync sales
CREATE OR REPLACE FUNCTION sync_sales()
RETURNS TRIGGER AS $$
BEGIN
    -- Update sale quantity in inventory
    UPDATE inventory
    SET sale_qty = (
        SELECT COALESCE(SUM(qty), 0)
        FROM daily_sales
        WHERE bar_id = NEW.bar_id
        AND brand_id = NEW.brand_id
        AND sale_date = NEW.date
    )
    WHERE bar_id = NEW.bar_id
    AND brand_id = NEW.brand_id
    AND date = NEW.date;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to sync sales
DROP TRIGGER IF EXISTS sync_sales_trigger ON daily_sales;
CREATE TRIGGER sync_sales_trigger
    AFTER INSERT OR UPDATE OR DELETE ON daily_sales
    FOR EACH ROW
    EXECUTE FUNCTION sync_sales();

-- Create function to initialize inventory for a new date
CREATE OR REPLACE FUNCTION initialize_inventory_for_date(
    p_bar_id UUID,
    p_date DATE
)
RETURNS VOID AS $$
BEGIN
    -- Insert inventory entries for all brands if they don't exist
    INSERT INTO inventory (bar_id, brand_id, date, opening_qty, receipt_qty, sale_qty)
    SELECT 
        p_bar_id,
        b.id,
        p_date,
        COALESCE((
            SELECT closing_qty 
            FROM inventory 
            WHERE bar_id = p_bar_id 
            AND brand_id = b.id 
            AND date = p_date - INTERVAL '1 day'
        ), 0),
        0,
        0
    FROM brands b
    WHERE NOT EXISTS (
        SELECT 1 
        FROM inventory 
        WHERE bar_id = p_bar_id 
        AND brand_id = b.id 
        AND date = p_date
    );
END;
$$ LANGUAGE plpgsql;

-- Create function to get inventory summary
CREATE OR REPLACE FUNCTION get_inventory_summary(
    p_bar_id UUID,
    p_start_date DATE,
    p_end_date DATE
)
RETURNS TABLE (
    brand_id BIGINT,
    brand_name TEXT,
    total_opening INTEGER,
    total_receipt INTEGER,
    total_sale INTEGER,
    total_closing INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        i.brand_id,
        b.name as brand_name,
        SUM(i.opening_qty) as total_opening,
        SUM(i.receipt_qty) as total_receipt,
        SUM(i.sale_qty) as total_sale,
        SUM(i.closing_qty) as total_closing
    FROM inventory i
    JOIN brands b ON i.brand_id = b.id
    WHERE i.bar_id = p_bar_id
    AND i.date BETWEEN p_start_date AND p_end_date
    GROUP BY i.brand_id, b.name
    ORDER BY b.name;
END;
$$ LANGUAGE plpgsql; 